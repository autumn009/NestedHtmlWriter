NestedHtmlWriter
〜楽してマシなXHTML文書をプログラムから出力したい　〜

●概要
　WWWの世界ではサーバサイド処理が行われることも多いのですが、その際、プログラムからXHTML文書を生成する作業が必要となります。このような処理を実現する方法は過去にいろいろ考案されているようですが、出力されるコードの確実性とラクチンさという意味で、イマイチだと感じていました。ということで、C#のusingステートメントとDisposeパターンを活用するNestedHtmlWriterというクラスライブラリを作ってみました。その内容をざっと紹介してみます。

●目的
　プログラムからXHTML文書を生成する際に、正しいXHTML文書であることを強制しながら出力を実現するライブラリを作成します。また、定型化された作業に対して、より少ない手間でシンプルなコードにより実現可能とします。XHTML文書全体だけでなく、一部分のみを出力するためにも使用可能とします。ライブラリはプログラム言語としてC#で使用することを前提とします。出力はXHTMLとします。ただし、実験という性格上、とりあえず必要な機能のみに限って、XHTMLの全てには対応しません。

●背景
　これまで、プログラムからXHTML文書を生成する場合には、writer.WriteLine("<p>はろ〜!</p>");のようなコードをよく書いていたわけですよ。しかし、これは1つのソース上に、プログラム言語とXHTMLの両方のコードが混在して分かりにくいし、書き間違ってもエラーが出ません。終了タグを書き間違って、writer.WriteLine("<p>はろ〜!<p>");なんて書いても、コンパイラも黙って通すし、Webブラウザも文句を言いません。でも、本当は危険なことで、まっとうにXHTMLを解釈するソフトに読ませた瞬間、エラーを食らうことになります。
　では、もっとマシな方法があるのかというと、たとえばASP.NETではオブジェクトのツリーを作って、それを元にHTML文書の生成を行うアーキテクチャになってます。これなら、開始タグと終了タグの入れ子構造は絶対に壊れないと期待できるように思えますが、実はそうでもありません。ASP.NETでは、バシバシ、タグを含む生の文字列を出力できちゃうからです。また、しかも、ツリー構造に制約はないので、明らかに間違ったHTML文書を構築することも簡単です。
　結果の正しさを検証するために、出力結果をHTML検証ツールで調べる方法もありますが、これも満足できません。プログラムから出力するということは、当然、入力条件が変わると出力も変わるわけで、ある入力ケースでの正しさを検証することはできても、全てのケースにおいて正しさを検証できるわけではありません。
　これじゃイヤだな〜、と思っていたのですが、あるプログラムで必要になって、これらの問題に対応する小さなライブラリを試作的に作ってみました。

●動作環境
　C#
　.NET Framework 1.1 (ビルドし直せばたぶん1.0でも問題ない)

●確実に閉じる

　まず、開いたタグを確実に閉じるような構造にしたいわけです。何はさておき、これはぜひ欲しいのです。
　NestedHtmlWriterでは、こんな感じにコーディングして実現します。
　なお、Nhという2文字が付いたクラスは、NestedHtmlWriter名前空間に属するNestedHtmlWriterクラスライブラリのクラスです。主に要素名が付いて、NhPならp要素を意味するクラスになります。
　話を戻して、最初のサンプルソースです。

using( NhP p = new NhP( Console.Out, null ) )
{
    p.WriteText("sample");
}

　これを実行すると、コンソールに、こんな出力を得ます。

<p>sample</p>

　ここでのポイントは、usingステートメントとDisposeパターンです。クラスNhPはIDisposableインターフェースを実装しています。usingステートメントはusingブロックを抜ける際に必ずIDisposableインターフェースのDisposeメソッドを呼びます。それにより、usingステートメントを使用して扱っている限り、どんな方法でブロックを抜けた場合にも、必ず終了タグが出力されるようになっています。普通に抜けて、breakやgotoで抜けても、例外発生で抜けても、です。これにより、開始タグと終了タグの整合性が強制されます。
　それだけではありません。横着者には嬉しいことに、終了タグを出力するコードを書く必要がないのです。それはブロックから抜けるときに自動的に挿入されるのです!　更に、不等号にもサヨナラです。"<"や">"はもうソースコードにありません。シフトを押しながら、しかも押しにくい場所にある不等号を頻繁に入力しなくて良いのです。
　ついでに余談を言えば、WriteTextは常に特殊な記号をエンコードするので、<や&を含む文字列を出力する場合にも、エンコードメソッド呼ばなきゃ、などと気を使う必要からも解放されます。これも横着者には嬉しい特徴ですね。
　更にもう1つメリットがあります。ここに生のタグを書けないことにより、直接タグを書いて文書の整合を壊すことができないのです。(とはいえ、出力に使うTextWriterを直接叩けば、いくらでも勝手な文字列を出力できちゃうわけですが……)
　なお、NhPクラスのコンストラクタの引数は、最初が出力するSystem.IO.TextWriter型の値。2番目が親要素を出力するクラス(NhBaseクラス)の値ですが、最上位の場合はnullを指定します。通常はnullしか指定しません。

●ネストする要素

　要素がネストしたときに正しく扱うにはどうするか。body要素の子にp要素を出力するには、こんなふうに書くのです。

using( NhBody body = new NhBody( Console.Out, null ) )
{
    using( NhP p = body.CreateP() )
    {
        p.WriteText("sample");
    }
}

　ちなみに、こうやってusingブロックがネストしていくので、"Nested"HtmlWriterという名前にしてみました。
　これは以下のような出力を得ます。

<body>
<p>sample</p>
</body>

　ここでポイントになるのは、子要素をCreateXXXメソッドで作成するという点です。ここでは、NhBodyクラスのCreatePメソッドで作っています。newで作成しないことに、どんな意味があるのかというと。まず、横着者としては引数が無い点が嬉しいですね。これで書くことが減りました。しかし、それは実は些細な長所でしかありません。これによって、他にいくつかの重要な機能が働きます。
　まず、要素によって子要素に作成可能な要素は変わってきます。body要素の子要素としてp要素は作れますが、p要素の子要素としてbody要素は作れません。つまり、NhBodyクラスにCreatePメソッドはありますが、NhPクラスにCreateBodyメソッドはありません。これにより、そこに出力することが許されない要素を出力するコードを書くことができなくなります。
　次に、親要素をロックできるという特徴が生まれます。これはこのあと説明します。
　最後に、適切な位置に改行を挿入することを可能とします。この例では、</p>のあとに改行が自動挿入されています。これは、</p>を出力する際、その親要素は内容にテキストを持たない要素であることを認識して、勝手に改行を足しても問題ないと判断して行っていることです。
　本当は内部的に他にもこれを使わねばならない理由があるのですが、以下略。

●二重の子要素の作成を抑止

　上の例だと、ちょっと書き換えると、body要素の子要素としてpを出力中に、もう1個pを作成してしまうことができます。

using( NhBody body = new NhBody( Console.Out, null ) )
{
    using( NhP p1 = body.CreateP() )
    {
        using( NhP p2 = body.CreateP() )
        {
            p2.WriteText("sample");
        }
    }
}

　子要素を作成中に、同じ親要素に属する子要素を更に作成させれば出力内容は正しいXHTML文書にならない恐れがあります。そのことを知らせるために、これを実行すると、NhExpception例外が出て、処理が中断されます。子要素の作成中は親要素がロックされていて、更に何かを書かせようとすると例外が発生して知らせます。これにより、意図しない構造を持った出力は防止されます。コンパイル時に検出はできませんが、実行時には検出されます。(速度が重要な場合には、このチェックをオフにすることもできます)

●XHTML文書全体を出力する

　ここまで説明した通りの要領で、XHTML文書全体を出力するサンプルソースを書いてみましょう。
　以下のサンプルソースは、文書全体を表現するNhDocumentクラス以外はだいたい見るだけで分かるでしょう。でも、横着者には長すぎます。

NhDocument doc = new NhDocument( Console.Out );
using( NhHtml html = doc.CreateHtml() )
{
    using( NhHead head = html.CreateHead() )
    {
        head.WriteTitle("サンプル出力");
    }
    using( NhBody body = html.CreateBody() )
    {
        using( NhHx h1 = body.CreateHx(1) )
        {
            h1.WriteText("サンプル出力");
        }
        using( NhP p1 = body.CreateP() )
        {
            p1.WriteText("これはサンプル出力です。");
        }
        using( NhP p2 = body.CreateP() )
        {
            p2.WriteText("もっと複雑に");
            using( NhBr br = p2.CreateBr() )
            {
            }
            using( NhA a = p2.CreateA() )
            {
                a.WriteAttribute("href","http://hoge");
                a.WriteText("ハイパーリンク");
            }
        }
    }
}

　これを実行すると以下のような結果が得られます。

<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>サンプル出力</title>
</head>
<body>
<h1>サンプル出力</h1>
<p>これはサンプル出力です。</p>
<p>もっと複雑に<br /><a href="http://hoge">ハイパーリンク</a></p>
</body>
</html>

　ちなみに結果が本当に指定されたDTDに合致するかどうか確認はしていません。あしからず。
　さて、横着者としては、もっと簡単に同じ結果を得たいわけです。
　というわけで、NhDocumentクラスのかわりに使うNhQuickDocumentクラスという横着用のクラスが用意してあります。その他、オブジェクトをCreateしないで出力するWriteXXXメソッドもあります。これらを活用すると、こんな感じにコンパクトに書けます。

using( NhQuickDocument doc = new NhQuickDocument( Console.Out, 
    "サンプル出力", null, null ) )
{
    doc.B.WriteHxText(1,"サンプル出力");
    doc.B.WritePText("これはサンプル出力です。");
    using( NhP p2 = doc.B.CreateP() )
    {
        p2.WriteText("もっと複雑に");
        p2.WriteBr();
        p2.WriteAText("http://hoge","ハイパーリンク");
    }
}

　WriteXXXメソッドは、よく使われる定型のパターンの専用のメソッドです。これで、かなりソースは小さくすっきりします。
　ちなみにNhQuickDocumentクラスのBプロパティは、body要素を出力するNhBodyクラスのインスタンスを提供します。

●残された課題
　ここまでやっても、完全に正しい文書の生成を強制できません。たとえば、NhHtmlクラスには、CreateHeadメソッドと、CreateBodyメソッドがありますが、誤った順番で呼び出しても、何の警告もありません。
　またWriteXXXメソッドを使うと短くなりますが、用意されたWriteXXXメソッドと要求が合致しないと使用できず、ソースは膨らんでしまいます。
　XHTMLの仕様も全て満たしていません。DOCTYPEではXHTML 1.1だと主張していますが本当はインチキです。実際はXHTML Basicのサブセットでしかありません。
　それから、これはXHTMLという特定の言語に対する1つの提案に過ぎず、一般のXML文書全般には対処できません。
　ASP.NET内で使う方法の確立も必要でしょう。ASP.NET文書の一部を、NestedHtmlWriterで出力するのは、おそらく難しくないと思います。
　内部実装の話でいうと、大量の継承を使いまくっているのが気持ち悪いです。
　1つの要素を出力するごとに1個のオブジェクトを生成する構造は、処理効率が悪いかも知れません。

●考察と感想
　残された課題はいろいろあれど、この程度のものでも役に立つというのも事実で、これからいろいろ使ってみようと思います。おそらく、完全を目指すことは無意味で、80%の出来で止めておくのが良いのでしょう。最大の目的はプログラマの負荷軽減ですが、どうせ負荷はゼロにならないので、より負荷が軽くなればそれは有益であると考えます。
　次の課題は、本当にこれを使うとラクチンなのかどうか、ということですね。できれば、いろいろな人に使ってみて欲しいと感じます。

●入手先
http://www.piedey.co.jp/softs/NestedHtmlWriter001.html
　金は取りませんので自由に使ってみてください。
　ソースも付いてます。
　配布規則に「また、改編したバージョンを配布する場合は、必ずソースコードを付けて下さい。」と書いてありますが、定型文がそのまま載っただけなので無視しても構いません。それから、「本ソフトウェアは、 NT-Toolsメーリングリスト にてサポートを行っています。質問などは、なるべくこちらのメーリングリストにお寄せ下さい。」も同じです。xml-usersメーリングリストでも構いません。

